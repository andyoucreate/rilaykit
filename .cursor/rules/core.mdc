---
description: Core coding standards and practices for the Standard framework
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
---

# Core Coding Standards

## Principles

- **DRY** (Don't Repeat Yourself) - Extract common logic, avoid duplication
- **YAGNI** (You Aren't Gonna Need It) - Don't build for hypothetical future requirements
- **DX First** - Developer experience matters, prefer clarity over cleverness
- **Elegant Code** - Readable at first glance, concise without verbosity, expressive of intent

## Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Files | kebab-case | `attribute-builders.ts` |
| Variables/Functions | camelCase | `loadOptions`, `handleClick` |
| React Components | PascalCase | `Button`, `DataGrid` |
| Constants | UPPER_CASE | `FILE_SIZE`, `COLORS` |
| Types/Interfaces | PascalCase (no "I" prefix) | `UserProfile`, `ButtonProps` |
| Enums | PascalCase with UPPER_CASE values | `Status.ACTIVE` |

## TypeScript

### Configuration
- `strict: true` enabled
- Prefer `unknown` over `any` when type is truly unknown
- Use `type` for unions and intersections, `interface` for object shapes

### Patterns
```typescript
// Use function keyword for declarations
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Arrow functions for callbacks and inline functions
const filtered = items.filter((item) => item.active);

// Export types separately
export type { UserProfile, CreateUserInput };

// Generic type inference
function useRecords<TValues extends Record<string, unknown>>(
  objectName: string
): UseQueryResult<TypedRecord<TValues>> { }
```

### Null Handling
```typescript
// Prefer nullish coalescing and optional chaining
const value = data?.nested?.field ?? defaultValue;

// Early return pattern for guards
function processUser(user: User | null) {
  if (!user) return null;
  if (!user.active) return null;
  
  // Main logic here
  return user.profile;
}
```

## React (v19+)

### Component Structure
```typescript
"use client";

import { useState } from "react";
import { cn } from "@/lib/utils";

// Types first
interface ButtonProps {
  variant?: "default" | "outline";
  children: React.ReactNode;
}

// Component with ref as regular prop (React 19)
function Button({ variant = "default", ref, children }: ButtonProps & { ref?: React.Ref<HTMLButtonElement> }) {
  return (
    <button ref={ref} className={cn(variants[variant])}>
      {children}
    </button>
  );
}

export { Button, type ButtonProps };
```

### State Management
- **TanStack Query** for server state (fetching, caching, mutations)
- **Zustand** for client state (UI state, user preferences)
- Multiple Zustand stores by domain, not one global store

```typescript
// Zustand store per domain
export const useUIStore = create<UIState>((set) => ({
  sidebarOpen: true,
  toggleSidebar: () => set((s) => ({ sidebarOpen: !s.sidebarOpen })),
}));

// TanStack Query for data
export function useRecords(objectName: string) {
  return useQuery({
    queryKey: recordsKeys.list(objectName),
    queryFn: () => client.listRecords(objectName),
  });
}
```

### Hooks
- Prefix with `use`
- One hook per file for complex hooks
- Co-locate simple hooks with their component

## File Organization

### Section Separators
Use section separators for files with multiple logical groups:

```typescript
// ============================================================================
// TYPES
// ============================================================================

interface Config { }

// ============================================================================
// HELPERS
// ============================================================================

function helper() { }

// ============================================================================
// MAIN EXPORT
// ============================================================================

export function main() { }
```

### Barrel Exports
- Selective barrel exports (not every folder needs index.ts)
- Package root always has index.ts
- Use when it simplifies imports

```typescript
// packages/schema/src/index.ts
export * from "./types";
export * from "./builders";
export * from "./runtime";
```

## Error Handling

Use custom exceptions for domain errors:

```typescript
// Define custom exceptions
export class RecordNotFoundError extends Error {
  constructor(public recordId: string) {
    super(`Record not found: ${recordId}`);
    this.name = "RecordNotFoundError";
  }
}

// Throw in services
function getRecord(id: string) {
  const record = await db.findById(id);
  if (!record) throw new RecordNotFoundError(id);
  return record;
}
```

## Async Patterns

Prefer simple async/await:

```typescript
async function fetchUserWithPosts(userId: string) {
  const user = await userService.getById(userId);
  if (!user) return null;
  
  const posts = await postService.getByUserId(userId);
  return { ...user, posts };
}
```

## Testing

### Framework
- **Vitest** for unit/integration tests
- Co-located in `tests/` folder at package root

### Structure
```typescript
import { describe, expect, it } from "vitest";

describe("RecordService", () => {
  describe("create", () => {
    it("should create a record with valid data", () => {
      // Arrange
      const input = { name: "Test" };
      
      // Act
      const result = service.create(input);
      
      // Assert
      expect(result.name).toBe("Test");
    });

    it("should throw on invalid data", () => {
      expect(() => service.create({})).toThrow();
    });

    // Test edge cases
    it("should handle empty string name", () => {
      expect(() => service.create({ name: "" })).toThrow();
    });
  });
});
```

### Coverage
- Target 80%+ on business logic
- Focus on edge cases over line coverage
- Skip coverage for trivial code (re-exports, simple getters)

## Development Workflow

### When Adding Features
1. **Implement the feature** following these standards
2. **Write tests** with edge cases
3. **Update documentation** if API changes

### When to Refactor
- Duplication detected (DRY violation)
- Cognitive complexity increasing
- Code smells (long functions, deep nesting)

## Tooling

### Biome
- Handles formatting and linting
- Imports organized automatically
- Run `pnpm lint` before committing

### Monorepo
- pnpm workspaces
- Turbo for build orchestration
- `workspace:*` for internal dependencies

```json
{
  "dependencies": {
    "@andyoucreate/schema": "workspace:*"
  }
}
```

## Code Review Checklist

When reviewing code, check for:
- [ ] Logic correctness and edge cases handled
- [ ] Style consistency with codebase
- [ ] Performance implications
- [ ] Long-term maintainability
- [ ] Tests included for new logic
- [ ] Documentation updated if needed

## Design System

### Philosophy
- **Notion/Attio style** - Clean, modern, minimal, exceptional UX
- **Dopamine-driven** - Smooth animations that feel satisfying
- **Clarity first** - Every element serves a purpose

### UI Stack
- **Shadcn UI** as base component library
- **Radix UI** for accessible primitives
- **Tailwind CSS v4** for styling
- **class-variance-authority (cva)** for component variants
- **Myna UI Icons** (`@mynaui/icons-react`) as primary icon library

### Component Patterns

```typescript
// Use cva for variants
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        outline: "border border-input bg-background hover:bg-accent",
        ghost: "hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 px-3 text-xs",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);
```

### Animations
Smooth, satisfying animations that add fluidity and dopamine:

```typescript
// Dialog/Modal pattern - fade + zoom
className={cn(
  "data-[state=open]:animate-in data-[state=closed]:animate-out",
  "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
  "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
  "duration-150 ease-out"
)}

// Overlay fade
className="data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 duration-150"
```

**Animation Guidelines:**
- Duration: 150ms for micro-interactions, 200-300ms for larger transitions
- Easing: `ease-out` for exits, `ease-in-out` for continuous
- Combine `fade` + `zoom` for modals/dialogs
- Combine `fade` + `slide` for sheets/drawers
- Use Tailwind's `animate-in`/`animate-out` utilities

### Borders & Focus
- **Borders**: Subtle, low contrast (`border-input`)
- **Focus**: Ring style (`focus-visible:ring-1 focus-visible:ring-ring`)
- **Hover**: Subtle background change (`hover:bg-accent`)

```typescript
// Standard focus pattern
"focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"

// Disabled state
"disabled:pointer-events-none disabled:opacity-50"
```

### Colors
- Use CSS custom properties for theming
- Semantic color names (`primary`, `destructive`, `muted`)
- Support system dark mode preference

```typescript
// Dynamic colors from constants
import { COLORS, type ColorId } from "@andyoucreate/constants";

const color = COLORS[variant];
style={{
  backgroundColor: color.background,
  borderColor: color.border,
  color: color.text,
}}
```

### Loading States
- **Lists/Tables**: Skeleton loaders
- **Actions/Buttons**: Spinner inside button
- **Forms**: Disabled state with opacity

```typescript
// Skeleton for lists
{isLoading ? (
  <Skeleton className="h-10 w-full" />
) : (
  <DataGrid data={data} />
)}

// Spinner for actions
<Button disabled={isPending}>
  {isPending && <Spinner className="size-4" />}
  Save
</Button>
```

### Spacing
- Follow Tailwind's spacing scale (4px base)
- Consistent gaps: `gap-2` (8px), `gap-4` (16px)
- Form fields: `space-y-4` between groups

### Empty States
Use the Empty component pattern:

```typescript
<Empty>
  <EmptyHeader>
    <EmptyMedia variant="icon">
      <PackageIcon />
    </EmptyMedia>
    <EmptyTitle>No products yet</EmptyTitle>
    <EmptyDescription>
      Get started by creating your first product.
    </EmptyDescription>
  </EmptyHeader>
  <Button>Create Product</Button>
</Empty>
```

### Data Slots
Use `data-slot` attributes for styling hooks:

```typescript
<div data-slot="grid-wrapper" className="...">
  <div data-slot="grid-header" className="...">
```

## Anti-Patterns to Avoid

- Over-engineering simple solutions
- Premature abstraction
- Deep nesting (use early returns)
- God components (split if too many responsibilities)
- Prop drilling (use context or Zustand for deep state)
- `any` type without justification
- console.log in production code
- Commented-out code (delete it, git remembers)
- Inline styles except for dynamic values (colors, sizes)
- Hard-coded colors (use CSS variables)
- Missing loading/error states
- Animations without purpose (every animation should improve UX)
