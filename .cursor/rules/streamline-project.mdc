---
description: 
globs: 
alwaysApply: false
---
# Streamline Project Overview

## Project Description
Streamline is a next-generation React library designed with modularity, type safety, and extensibility at its core. Built on a configurable object-based architecture with builder patterns, it provides a complete solution for complex form workflows while maintaining flexibility and performance.

**Architectural Philosophy**: Streamline follows a builder pattern approach with object-based configuration, enabling developers to create custom components and build forms in a fluid and intuitive manner.

## Core Architectural Principles

### 1. Object-Based Builder Configuration
- **Builder Pattern**: Fluid construction of configurations and forms
- **Configurable Components**: Each component is configurable via configuration objects
- **Renderer/Logic Separation**: Logic separated from rendering for maximum flexibility
- **Type Safety**: Fully typed configuration with TypeScript

### 2. Extensible Component System
- **Input Components**: Components that modify values (text, select, etc.)
- **Layout Components**: Display-only components (headings, containers, etc.)
- **Custom Renderers**: Ability to define custom renderers
- **Registration System**: Component registration system

### 3. Event-Driven Architecture
- **Event Communication**: Decoupled communication via events
- **Extensibility**: Easy addition of new behaviors
- **Debugging**: Clear event flow for debugging
- **Testability**: Isolated components for better testing

## Configuration and Builder Architecture

### Component Configuration

```typescript
// Component types
type ComponentType = 'input' | 'layout';
type InputType = 'text' | 'email' | 'password' | 'number' | 'select' | 'checkbox' | 'textarea' | 'file' | 'date';
type LayoutType = 'heading' | 'paragraph' | 'container' | 'divider' | 'spacer' | 'alert';

// Validation result
interface ValidationResult {
  readonly isValid: boolean;
  readonly errors: ValidationError[];
  readonly warnings?: ValidationWarning[];
}

interface ValidationError {
  readonly code: string;
  readonly message: string;
  readonly path?: string[];
}

interface ValidationWarning {
  readonly code: string;
  readonly message: string;
  readonly path?: string[];
}

// Validation context
interface ValidationContext {
  readonly fieldId: string;
  readonly formData: Record<string, any>;
  readonly fieldProps: Record<string, any>;
  readonly touched: boolean;
  readonly dirty: boolean;
}

// Validator function - can be sync or async
type ValidatorFunction<TProps = any> = (
  value: any,
  context: ValidationContext,
  props: TProps
) => ValidationResult | Promise<ValidationResult>;

// Validation configuration
interface ValidationConfig<TProps = any> {
  readonly validator?: ValidatorFunction<TProps>;
  readonly debounceMs?: number;
  readonly validateOnChange?: boolean;
  readonly validateOnBlur?: boolean;
  readonly validateOnSubmit?: boolean;
  readonly dependencies?: string[]; // Fields this validation depends on
}

// Base component configuration
interface ComponentConfig<TProps = any> {
  readonly id: string;
  readonly type: ComponentType;
  readonly subType: InputType | LayoutType;
  readonly name: string;
  readonly description?: string;
  readonly category?: string;
  readonly renderer: ComponentRenderer<TProps>;
  readonly options?: ComponentOptions<TProps>;
  readonly validation?: ValidationConfig<TProps>;
  readonly defaultProps?: Partial<TProps>;
}

// Component renderer
interface ComponentRenderer<TProps = any> {
  (props: ComponentRenderProps<TProps>): React.ReactElement;
}

interface ComponentRenderProps<TProps = any> {
  id: string;
  props: TProps;
  value?: any;
  onChange?: (value: any) => void;
  onBlur?: () => void;
  error?: ValidationError[];
  warnings?: ValidationWarning[];
  touched?: boolean;
  disabled?: boolean;
  isValidating?: boolean;
  [key: string]: any;
}

// Configuration options
interface ComponentOptions<TProps = any> {
  readonly configurable?: Array<{
    key: keyof TProps;
    type: 'string' | 'number' | 'boolean' | 'select' | 'array';
    label: string;
    options?: any[];
    default?: any;
  }>;
  readonly previewProps?: Partial<TProps>;
  readonly icon?: string;
  readonly tags?: string[];
}

// Main configuration class
class StreamlineConfig {
  private components = new Map<string, ComponentConfig>();
  
  // Add a component to the configuration
  addComponent<TProps = any>(
    subType: InputType | LayoutType,
    config: Omit<ComponentConfig<TProps>, 'id' | 'subType'> & { id?: string }
  ): this {
    const componentId = config.id || `${config.type}-${subType}-${Date.now()}`;
    
    const fullConfig: ComponentConfig<TProps> = {
      id: componentId,
      subType,
      ...config,
    };
    
    this.components.set(componentId, fullConfig as ComponentConfig);
    return this;
  }
  
  // Get a component
  getComponent(id: string): ComponentConfig | undefined {
    return this.components.get(id);
  }
  
  // List components by type
  getComponentsByType(type: ComponentType): ComponentConfig[] {
    return Array.from(this.components.values()).filter(comp => comp.type === type);
  }
  
  // List components by sub-type
  getComponentsBySubType(subType: InputType | LayoutType): ComponentConfig[] {
    return Array.from(this.components.values()).filter(comp => comp.subType === subType);
  }
  
  // List all components
  getAllComponents(): ComponentConfig[] {
    return Array.from(this.components.values());
  }
  
  // Export configuration
  export(): Record<string, ComponentConfig> {
    return Object.fromEntries(this.components);
  }
  
  // Import configuration
  import(config: Record<string, ComponentConfig>): this {
    Object.entries(config).forEach(([id, componentConfig]) => {
      this.components.set(id, componentConfig);
    });
    return this;
  }
}
```

### Component Configuration Examples with Validation

```typescript
// Validation utilities
const createZodValidator = <T>(schema: z.ZodSchema<T>): ValidatorFunction => {
  return async (value, context, props) => {
    try {
      await schema.parseAsync(value);
      return {
        isValid: true,
        errors: [],
      };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          isValid: false,
          errors: error.errors.map(err => ({
            code: err.code,
            message: err.message,
            path: err.path.map(String),
          })),
        };
      }
      return {
        isValid: false,
        errors: [{
          code: 'unknown',
          message: 'Unknown validation error',
        }],
      };
    }
  };
};

const createCustomValidator = (
  validationFn: (value: any, context: ValidationContext) => boolean | string | Promise<boolean | string>
): ValidatorFunction => {
  return async (value, context, props) => {
    try {
      const result = await validationFn(value, context);
      
      if (result === true) {
        return { isValid: true, errors: [] };
      }
      
      if (result === false) {
        return {
          isValid: false,
          errors: [{
            code: 'validation_failed',
            message: 'Validation failed',
          }],
        };
      }
      
      // If it's a string, it's the error message
      return {
        isValid: false,
        errors: [{
          code: 'validation_failed',
          message: String(result),
        }],
      };
    } catch (error) {
      return {
        isValid: false,
        errors: [{
          code: 'validation_error',
          message: error instanceof Error ? error.message : 'Validation error',
        }],
      };
    }
  };
};

// Create configuration with validation
const designSystemConfig = new StreamlineConfig();

// Add input components with validation
designSystemConfig
  .addComponent('text', {
    type: 'input',
    name: 'Text Input',
    description: 'Standard text input field',
    category: 'inputs',
    renderer: (props) => (
      <div className="streamline-field">
        <label htmlFor={props.id}>{props.props.label}</label>
        <input
          id={props.id}
          type="text"
          value={props.value || ''}
          onChange={(e) => props.onChange?.(e.target.value)}
          onBlur={props.onBlur}
          placeholder={props.props.placeholder}
          disabled={props.disabled}
          className={props.error?.length ? 'error' : ''}
          maxLength={props.props.maxLength}
          {...props.props.inputProps}
        />
        {props.isValidating && (
          <span className="validation-spinner">Validating...</span>
        )}
        {props.error?.map((error, index) => (
          <span key={index} className="error-message">{error.message}</span>
        ))}
        {props.warnings?.map((warning, index) => (
          <span key={index} className="warning-message">{warning.message}</span>
        ))}
      </div>
    ),
    validation: {
      validator: createZodValidator(
        z.string()
          .min(1, 'This field is required')
          .max(100, 'Maximum 100 characters')
      ),
      debounceMs: 300,
      validateOnChange: true,
      validateOnBlur: true,
    },
    options: {
      configurable: [
        { key: 'label', type: 'string', label: 'Label' },
        { key: 'placeholder', type: 'string', label: 'Placeholder' },
        { key: 'maxLength', type: 'number', label: 'Max Length' },
        { key: 'required', type: 'boolean', label: 'Required' },
      ],
      previewProps: {
        label: 'Text Example',
        placeholder: 'Enter your text...',
      },
      icon: 'text-field',
      tags: ['input', 'text', 'basic'],
    },
    defaultProps: {
      label: '',
      placeholder: '',
      maxLength: 100,
      required: false,
    },
  })
  .addComponent('email', {
    type: 'input',
    name: 'Email Input',
    description: 'Email input field with validation',
    category: 'inputs',
    renderer: (props) => (
      <div className="streamline-field">
        <label htmlFor={props.id}>{props.props.label}</label>
        <input
          id={props.id}
          type="email"
          value={props.value || ''}
          onChange={(e) => props.onChange?.(e.target.value)}
          onBlur={props.onBlur}
          placeholder={props.props.placeholder}
          disabled={props.disabled}
          className={props.error?.length ? 'error' : ''}
        />
        {props.isValidating && (
          <span className="validation-spinner">Checking...</span>
        )}
        {props.error?.map((error, index) => (
          <span key={index} className="error-message">{error.message}</span>
        ))}
      </div>
    ),
    validation: {
      validator: async (value, context, props) => {
        // Zod validation for email format
        const zodResult = await createZodValidator(
          z.string().email('Invalid email format')
        )(value, context, props);
        
        if (!zodResult.isValid) {
          return zodResult;
        }
        
        // Custom async validation - check if email already exists
        if (props.checkUniqueness && value) {
          try {
            const isUnique = await checkEmailUniqueness(value);
            if (!isUnique) {
              return {
                isValid: false,
                errors: [{
                  code: 'email_exists',
                  message: 'This email address is already in use',
                }],
              };
            }
          } catch (error) {
            return {
              isValid: true,
              errors: [],
              warnings: [{
                code: 'uniqueness_check_failed',
                message: 'Unable to verify email uniqueness',
              }],
            };
          }
        }
        
        return { isValid: true, errors: [] };
      },
      debounceMs: 500,
      validateOnChange: false,
      validateOnBlur: true,
    },
    options: {
      configurable: [
        { key: 'label', type: 'string', label: 'Label' },
        { key: 'placeholder', type: 'string', label: 'Placeholder' },
        { key: 'checkUniqueness', type: 'boolean', label: 'Check Uniqueness' },
        { key: 'required', type: 'boolean', label: 'Required' },
      ],
      previewProps: {
        label: 'Email Address',
        placeholder: 'example@domain.com',
        checkUniqueness: false,
      },
      icon: 'email',
      tags: ['input', 'email', 'validation'],
    },
    defaultProps: {
      checkUniqueness: false,
    },
  });

// Utility functions for async validations
async function checkEmailUniqueness(email: string): Promise<boolean> {
  // API call simulation
  return new Promise((resolve) => {
    setTimeout(() => {
      // Simulate some existing emails
      const existingEmails = ['test@example.com', 'admin@example.com'];
      resolve(!existingEmails.includes(email.toLowerCase()));
    }, 1000);
  });
}
```

### Form Construction

```typescript
// Form field configuration
interface FormFieldConfig {
  readonly id: string;
  readonly componentId: string;
  readonly props: Record<string, any>;
  readonly validation?: ValidationRules;
  readonly conditional?: ConditionalConfig;
}

// Form builder class
class FormBuilder {
  private config: StreamlineConfig;
  private fields: FormFieldConfig[] = [];
  private schema: z.ZodSchema | null = null;
  private formId: string;
  
  constructor(config: StreamlineConfig, formId?: string) {
    this.config = config;
    this.formId = formId || `form-${Date.now()}`;
  }
  
  // Add a field to the form
  addField(
    fieldId: string, 
    componentSubType: InputType | LayoutType, 
    props: Record<string, any> = {},
    options?: {
      validation?: ValidationRules;
      conditional?: ConditionalConfig;
    }
  ): this {
    // Find the corresponding component
    const component = this.config.getComponentsBySubType(componentSubType)[0];
    
    if (!component) {
      throw new Error(`Component with subType "${componentSubType}" not found in configuration`);
    }
    
    const fieldConfig: FormFieldConfig = {
      id: fieldId,
      componentId: component.id,
      props: { ...component.defaultProps, ...props },
      validation: options?.validation,
      conditional: options?.conditional,
    };
    
    this.fields.push(fieldConfig);
    return this;
  }
  
  // Add field by specific component ID
  addComponent(
    fieldId: string,
    componentId: string,
    props: Record<string, any> = {},
    options?: {
      validation?: ValidationRules;
      conditional?: ConditionalConfig;
    }
  ): this {
    const component = this.config.getComponent(componentId);
    
    if (!component) {
      throw new Error(`Component with ID "${componentId}" not found in configuration`);
    }
    
    const fieldConfig: FormFieldConfig = {
      id: fieldId,
      componentId,
      props: { ...component.defaultProps, ...props },
      validation: options?.validation,
      conditional: options?.conditional,
    };
    
    this.fields.push(fieldConfig);
    return this;
  }
  
  // Set validation schema
  setSchema(schema: z.ZodSchema): this {
    this.schema = schema;
    return this;
  }
  
  // Build final configuration
  build(): FormConfiguration {
    return {
      id: this.formId,
      fields: this.fields,
      schema: this.schema,
      config: this.config,
    };
  }
}

// Final form configuration
interface FormConfiguration {
  readonly id: string;
  readonly fields: FormFieldConfig[];
  readonly schema: z.ZodSchema | null;
  readonly config: StreamlineConfig;
}
```

## Multi-Step Forms with Workflows

### Multi-Step Workflow Architecture

```typescript
// Multi-step workflow types
interface StepConfig {
  readonly id: string;
  readonly title: string;
  readonly description?: string;
  readonly fields: string[]; // Field IDs for this step
  readonly validation?: StepValidationConfig;
  readonly conditional?: StepConditionalConfig;
  readonly customRenderer?: StepRenderer;
  readonly allowSkip?: boolean;
  readonly requiredToComplete?: boolean;
}

interface StepValidationConfig {
  readonly validator?: (stepData: Record<string, any>, allFormData: Record<string, any>) => ValidationResult | Promise<ValidationResult>;
  readonly validateOnStepChange?: boolean;
  readonly blockNextIfInvalid?: boolean;
}

interface StepConditionalConfig {
  readonly condition: (formData: Record<string, any>) => boolean;
  readonly action: 'show' | 'hide' | 'skip';
}

interface StepRenderer {
  (props: StepRenderProps): React.ReactElement;
}

interface StepRenderProps {
  step: StepConfig;
  fields: FormFieldConfig[];
  formData: Record<string, any>;
  errors: Record<string, ValidationError[]>;
  onFieldChange: (fieldId: string, value: any) => void;
  onNext: () => void;
  onPrevious: () => void;
  onSkip?: () => void;
  isFirstStep: boolean;
  isLastStep: boolean;
  currentStepIndex: number;
  totalSteps: number;
}

// Workflow configuration
interface WorkflowConfig {
  readonly id: string;
  readonly name: string;
  readonly description?: string;
  readonly steps: StepConfig[];
  readonly navigation?: NavigationConfig;
  readonly persistence?: PersistenceConfig;
  readonly completion?: CompletionConfig;
}

// Workflow builder class
class WorkflowBuilder {
  private config: StreamlineConfig;
  private workflow: WorkflowConfig;
  private steps: StepConfig[] = [];
  
  constructor(config: StreamlineConfig, workflowId: string, name: string) {
    this.config = config;
    this.workflow = {
      id: workflowId,
      name,
      steps: [],
    };
  }
  
  // Add a configured step
  addStep(
    stepId: string,
    title: string,
    fieldIds: string[],
    options?: {
      description?: string;
      validation?: StepValidationConfig;
      conditional?: StepConditionalConfig;
      customRenderer?: StepRenderer;
      allowSkip?: boolean;
      requiredToComplete?: boolean;
    }
  ): this {
    const step: StepConfig = {
      id: stepId,
      title,
      fields: fieldIds,
      description: options?.description,
      validation: options?.validation,
      conditional: options?.conditional,
      customRenderer: options?.customRenderer,
      allowSkip: options?.allowSkip || false,
      requiredToComplete: options?.requiredToComplete !== false,
    };
    
    this.steps.push(step);
    return this;
  }
  
  // Add a step with custom rendering (hardcoded)
  addCustomStep(
    stepId: string,
    title: string,
    renderer: StepRenderer,
    options?: {
      description?: string;
      validation?: StepValidationConfig;
      conditional?: StepConditionalConfig;
      allowSkip?: boolean;
      requiredToComplete?: boolean;
    }
  ): this {
    const step: StepConfig = {
      id: stepId,
      title,
      fields: [], // No automatic fields for custom steps
      customRenderer: renderer,
      description: options?.description,
      validation: options?.validation,
      conditional: options?.conditional,
      allowSkip: options?.allowSkip || false,
      requiredToComplete: options?.requiredToComplete !== false,
    };
    
    this.steps.push(step);
    return this;
  }
  
  // Build final workflow
  build(): WorkflowConfig {
    return {
      ...this.workflow,
      steps: this.steps,
    };
  }
}

// Multi-step form class
class MultiStepFormBuilder {
  private config: StreamlineConfig;
  private formConfig: FormConfiguration;
  private workflow: WorkflowConfig;
  
  constructor(
    config: StreamlineConfig,
    formConfig: FormConfiguration,
    workflow: WorkflowConfig
  ) {
    this.config = config;
    this.formConfig = formConfig;
    this.workflow = workflow;
  }
  
  // Create multi-step form from existing form
  static fromForm(
    formConfig: FormConfiguration,
    workflow: WorkflowConfig
  ): MultiStepFormBuilder {
    return new MultiStepFormBuilder(
      formConfig.config,
      formConfig,
      workflow
    );
  }
  
  // Get fields for a given step
  getStepFields(stepId: string): FormFieldConfig[] {
    const step = this.workflow.steps.find(s => s.id === stepId);
    if (!step) return [];
    
    return step.fields
      .map(fieldId => this.formConfig.fields.find(f => f.id === fieldId))
      .filter(Boolean) as FormFieldConfig[];
  }
  
  // Get complete configuration
  getConfig(): {
    form: FormConfiguration;
    workflow: WorkflowConfig;
    config: StreamlineConfig;
  } {
    return {
      form: this.formConfig,
      workflow: this.workflow,
      config: this.config,
    };
  }
}
```

### FormField Component for Granular Control

```typescript
// FormField component for granular control
interface FormFieldProps {
  id: string;
  formData?: Record<string, any>;
  errors?: Record<string, ValidationError[]>;
  touched?: Set<string>;
  disabled?: boolean;
  onChange?: (fieldId: string, value: any) => void;
  onBlur?: (fieldId: string) => void;
  configuration?: StreamlineConfig;
  fieldConfig?: FormFieldConfig;
  // Override props
  customRenderer?: ComponentRenderer;
  customProps?: Record<string, any>;
  // Multi-step context props
  stepContext?: {
    stepId: string;
    stepIndex: number;
    totalSteps: number;
  };
}

const FormField: React.FC<FormFieldProps> = ({
  id,
  formData = {},
  errors = {},
  touched = new Set(),
  disabled = false,
  onChange,
  onBlur,
  configuration,
  fieldConfig,
  customRenderer,
  customProps = {},
  stepContext,
}) => {
  // Find field configuration
  const resolvedFieldConfig = fieldConfig || 
    configuration?.getAllComponents().find(comp => 
      comp.id === id || comp.subType === id
    );
  
  if (!resolvedFieldConfig && !customRenderer) {
    console.warn(`FormField: No configuration found for field "${id}"`);
    return null;
  }
  
  // Use custom renderer or configuration renderer
  const renderer = customRenderer || resolvedFieldConfig?.renderer;
  
  if (!renderer) {
    console.warn(`FormField: No renderer found for field "${id}"`);
    return null;
  }
  
  // Prepare props for renderer
  const componentProps = {
    ...resolvedFieldConfig?.defaultProps,
    ...resolvedFieldConfig?.props,
    ...customProps,
  };
  
  const renderProps: ComponentRenderProps = {
    id,
    props: componentProps,
    value: formData[id],
    onChange: onChange ? (value) => onChange(id, value) : undefined,
    onBlur: onBlur ? () => onBlur(id) : undefined,
    error: errors[id] || [],
    touched: touched.has(id),
    disabled,
    stepContext,
  };
  
  return (
    <div className="form-field-wrapper" data-field-id={id}>
      {renderer(renderProps)}
    </div>
  );
};
```

## Mono-Repo Architecture

```
streamline/
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ core/                    # @streamline/core
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/         # StreamlineConfig, ComponentConfig
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation/     # Validation utilities, types
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/          # Core TypeScript types
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ form-builder/           # @streamline/form-builder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builders/       # FormBuilder class
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/     # FormRenderer, FormField
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/          # useForm, useValidation
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ workflow/               # @streamline/workflow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builders/       # WorkflowBuilder, MultiStepFormBuilder
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/     # MultiStepForm, StepIndicator
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/          # useWorkflow, useStep
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ components/             # @streamline/components (future)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inputs/         # Text, Email, Password, Select, etc.
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layouts/        # Heading, Alert, Container, etc.
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ presets/        # Pre-configured component sets
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ validators/             # @streamline/validators
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zod/           # Zod integration utilities
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ yup/           # Yup integration utilities
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom/        # Custom validation utilities
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ themes/                 # @streamline/themes (future)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ default/       # Default theme
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ material/      # Material Design theme
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tailwind/      # Tailwind CSS theme
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ dev-tools/              # @streamline/dev-tools
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builder/       # Visual form builder
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inspector/     # Component inspector
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ preview/       # Live preview
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ streamline/             # @streamline/streamline (main package)
‚îÇ       ‚îú‚îÄ‚îÄ src/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts        # Re-exports from all packages
‚îÇ       ‚îú‚îÄ‚îÄ package.json
‚îÇ       ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ docs/                   # Documentation site (Next.js)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ playground/             # Interactive playground (Vite + React)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ storybook/              # Storybook for component showcase
‚îÇ       ‚îú‚îÄ‚îÄ stories/
‚îÇ       ‚îú‚îÄ‚îÄ .storybook/
‚îÇ       ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îú‚îÄ‚îÄ build/                  # Build configuration
‚îÇ   ‚îú‚îÄ‚îÄ eslint-config/          # Shared ESLint config
‚îÇ   ‚îú‚îÄ‚îÄ typescript-config/      # Shared TypeScript config
‚îÇ   ‚îî‚îÄ‚îÄ test-utils/             # Shared testing utilities
‚îÇ
‚îú‚îÄ‚îÄ package.json                # Root package.json with workspaces
‚îú‚îÄ‚îÄ turbo.json                  # Turbo configuration
‚îú‚îÄ‚îÄ tsconfig.json               # Root TypeScript config
‚îú‚îÄ‚îÄ .eslintrc.js                # Root ESLint config
‚îî‚îÄ‚îÄ README.md                   # Project README
```

### Package Dependencies

```json
// Root package.json
{
  "name": "streamline-monorepo",
  "private": true,
  "workspaces": [
    "packages/*",
    "apps/*",
    "tools/*"
  ],
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "type-check": "turbo run type-check"
  },
  "devDependencies": {
    "turbo": "^1.10.0",
    "typescript": "^5.0.0",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0"
  }
}
```

```json
// packages/core/package.json
{
  "name": "@streamline/core",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src"
  },
  "peerDependencies": {
    "react": ">=18.0.0",
    "typescript": ">=5.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.0"
  }
}
```

```json
// packages/form-builder/package.json
{
  "name": "@streamline/form-builder",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "dependencies": {
    "@streamline/core": "workspace:*"
  },
  "peerDependencies": {
    "react": ">=18.0.0",
    "react-dom": ">=18.0.0"
  }
}
```

```json
// packages/streamline/package.json (main package)
{
  "name": "@streamline/streamline",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "dependencies": {
    "@streamline/core": "workspace:*",
    "@streamline/form-builder": "workspace:*",
    "@streamline/workflow": "workspace:*",
    "@streamline/components": "workspace:*",
    "@streamline/validators": "workspace:*"
  },
  "peerDependencies": {
    "react": ">=18.0.0",
    "react-dom": ">=18.0.0"
  }
}
```

### Usage Examples

```typescript
// Simple usage (main package)
import { StreamlineConfig, FormBuilder, TextInput, EmailInput } from '@streamline/streamline';

// Advanced usage (individual packages)
import { StreamlineConfig } from '@streamline/core';
import { FormBuilder } from '@streamline/form-builder';
import { WorkflowBuilder } from '@streamline/workflow';
import { TextInput, EmailInput } from '@streamline/components';
import { createZodValidator } from '@streamline/validators';

// Create configuration
const config = new StreamlineConfig()
  .addComponent('text', TextInput)
  .addComponent('email', EmailInput);

// Build form
const contactForm = new FormBuilder(config)
  .addField('name', 'text', { label: 'Full Name' })
  .addField('email', 'email', { label: 'Email Address' })
  .build();

// Build workflow
const registrationWorkflow = new WorkflowBuilder(config, 'registration', 'User Registration')
  .addStep('personal', 'Personal Info', ['name', 'email'])
  .addStep('verification', 'Verification', ['code'])
  .build();
```

Cette architecture mono-repo offre :

## üéØ **Avantages**

### **Simplicit√©**
- Packages focalis√©s sur une responsabilit√©
- D√©pendances claires entre packages
- API coh√©rente √† travers tous les packages

### **Flexibilit√©**
- Import granulaire (packages individuels)
- Import simple (package principal)
- Extensibilit√© par packages additionnels

### **Developer Experience**
- Turbo pour builds rapides
- Workspaces pour gestion des d√©pendances
- Documentation et playground int√©gr√©s

### **Maintenance**
- Code partag√© centralis√© dans `core`
- Versions synchronis√©es
- Tests et linting uniformes