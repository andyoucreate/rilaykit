---
title: TypeScript Support
description: How RilayKit provides full type safety with intelligent autocompletion for component types and props.
---
import { Callout } from 'fumadocs-ui/components/callout';

RilayKit is built with TypeScript-first principles. The `ril` instance uses generic type accumulation to track your registered components, providing compile-time validation and intelligent autocompletion throughout your form and workflow definitions.

## How Type Accumulation Works

Each call to `.addComponent()` extends the generic type parameter of the `ril` instance. This means TypeScript automatically knows which component types are available and what props they accept.

```tsx title="lib/rilay.ts"
import { ril } from '@rilaykit/core';
import { TextInput, SelectInput } from '@/components';

interface TextInputProps {
  label: string;
  placeholder?: string;
}

interface SelectInputProps {
  label: string;
  options: Array<{ value: string; label: string }>;
  multiple?: boolean;
}

// Each .addComponent() call extends the type
export const rilay = ril
  .create()
  .addComponent('text', {
    name: 'Text Input',
    renderer: TextInput,
  })
  .addComponent('select', {
    name: 'Select Input',
    renderer: SelectInput,
  });

// rilay is now typed as ril<{ text: TextInputProps; select: SelectInputProps }>
```

## Component Type Autocompletion

When building forms, the `type` field autocompletes to only the registered component types:

```tsx
const form = rilay
  .form('user-form')
  .add({
    id: 'username',
    type: 'text',  // ✅ Autocompletes: 'text' | 'select'
    props: {
      label: 'Username',
      placeholder: 'Enter your username',
    },
  });
```

Using an unregistered type produces a compile-time error:

```tsx
.add({
  type: 'checkbox',  // ❌ Type '"checkbox"' is not assignable to type '"text" | "select"'
  props: { label: 'Accept' },
})
```

## Props Type Inference

Once you select a component type, the `props` object is automatically typed to match that component's props interface:

```tsx
.add({
  id: 'country',
  type: 'select',
  props: {
    label: 'Country',
    options: [{ value: 'us', label: 'United States' }],  // ✅ Required for select
    multiple: true,   // ✅ Available on SelectInputProps
  },
})
```

Invalid props are caught at compile time:

```tsx
.add({
  id: 'email',
  type: 'text',
  props: {
    label: 'Email',
    options: [],       // ❌ 'options' does not exist on TextInputProps
    multiple: false,   // ❌ 'multiple' does not exist on TextInputProps
  },
})
```

## Multi-Field Rows

Type safety is maintained when adding multiple fields to the same row:

```tsx
const form = rilay
  .form('registration')
  .add(
    {
      id: 'firstName',
      type: 'text',       // ✅ Typed as TextInputProps
      props: { label: 'First Name' },
    },
    {
      id: 'lastName',
      type: 'text',       // ✅ Typed as TextInputProps
      props: { label: 'Last Name' },
    }
  );
```

## Immutable API

The `ril` instance is immutable — each `.addComponent()` returns a **new** instance with an extended type. This ensures type safety across your application:

```tsx
const base = ril.create();
// base is ril<Record<string, never>> — no components

const withText = base.addComponent('text', { renderer: TextInput });
// withText is ril<{ text: TextInputProps }>

const withBoth = withText.addComponent('select', { renderer: SelectInput });
// withBoth is ril<{ text: TextInputProps; select: SelectInputProps }>
```

<Callout type="info">
Because the API is immutable, always chain your `.addComponent()` calls or assign the final result. Calling `.addComponent()` without using the return value has no effect.
</Callout>

## Workflows

Type safety extends to workflows. When building steps, the `formConfig` accepts both a `FormConfiguration` and a `form` builder instance:

```tsx
const step1Form = rilay.form('personal-info')
  .add({ id: 'name', type: 'text', props: { label: 'Name' } });

const workflow = rilay.flow('onboarding', 'Onboarding')
  .addStep({
    id: 'personal',
    title: 'Personal Information',
    formConfig: step1Form,  // ✅ Type-checked
  });
```

## IDE Experience

With RilayKit's type system, your IDE provides:

- **Autocompletion** for component types, props, field IDs
- **Error highlighting** for invalid types or props before running code
- **Go to definition** navigation to component interfaces
- **Refactoring** — rename component types safely across the entire codebase

## Tips

- Define prop interfaces explicitly for each component — this gives you the best autocompletion
- Use a single shared `rilay` instance exported from a central file (e.g., `lib/rilay.ts`)
- Let TypeScript infer the generic types — avoid manually specifying them
