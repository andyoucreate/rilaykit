---
title: Building Forms
description: How to use the fluent API to build form configurations.
---
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';

Building a form configuration starts from your central `rilay` instance. By calling `form.create(rilay)`, you get a form builder that has access to all your pre-configured components and renderers.

<Callout>
Before proceeding, make sure you have created and configured a shared `rilay` instance as shown in the [Your First Form](/docs/getting-started/your-first-form) guide.
</Callout>

## The Form Building Process

<Steps>
<Step>
### 1. Start with `form()`

Call `form.create(rilay, ` on your `rilay` instance to begin a new form definition. You should provide a unique ID for your form.

```tsx
import { rilay } from '@/lib/rilay';

const loginForm = form.create(rilay, 'login');
```
</Step>
<Step>
### 2. Add Fields and Rows

The builder provides a powerful polymorphic `.add()` method that handles multiple use cases:

- **Single field**: `.add(fieldConfig)` - Adds a field on its own row
- **Multiple fields**: `.add(field1, field2, field3)` - Adds multiple fields on the same row (max 3)
- **Array syntax**: `.add([field1, field2], options)` - Explicit row control with options

```tsx
const registrationForm = rilay
  .form_OLD('registration')
  // Add multiple fields on the same row
  .add(
    {
      id: 'firstName',
      type: 'text', // This type must exist in your component registry
      props: { label: 'First Name' },
    },
    {
      id: 'lastName',
      type: 'text',
      props: { label: 'Last Name' },
    }
  )
  // Add a single field on its own row
  .add({
    id: 'email',
    type: 'email', // Assumes an 'email' type is registered
    props: { label: 'Email Address' },
  });
```

You can also use the array syntax for explicit control over row options:

```tsx
const formWithOptions = rilay
  .form_OLD('styled-form')
  .add([
    { id: 'field1', type: 'text', props: { label: 'Field 1' } },
    { id: 'field2', type: 'text', props: { label: 'Field 2' } },
  ], { 
    spacing: 'loose', 
    alignment: 'center' 
  });
```
</Step>

</Steps>

## Auto-Generated IDs

One of the key improvements in the new API is automatic ID generation. If you don't provide an `id` field, one will be generated for you:

```tsx
const quickForm = rilay
  .form_OLD('quick-form')
  .add(
    { type: 'text', props: { label: 'Name' } }, // Will get id: 'field-1'
    { type: 'email', props: { label: 'Email' } }, // Will get id: 'field-2'
    { type: 'text', props: { label: 'Phone' } } // Will get id: 'field-3'
  );
```

## When to use `.build()`

You may have noticed we don't always call `.build()` in our examples. This is because components like `<Form>` and workflow steps are smart enough to build the configuration for you.

However, you should call `.build()` manually when you need the final, serializable `FormConfiguration` object. For instance:

- To serialize the form and save it as JSON.
- To pass the configuration to a custom function or a third-party tool.
- For debugging purposes, to inspect the generated configuration.

```tsx
const formConfig = rilay
  .form_OLD('my-form')
  .add({ id: 'field1', type: 'text' })
  .build(); // Manually build the config

console.log(formConfig.allFields);
```

## Field Configuration

The `fieldConfig` object you pass to `.add()` has the following shape:

```ts
interface FieldConfig {
  id?: string; // Optional - auto-generated if not provided
  type: string; // The component type to render from your registry
  props?: Record<string, any>; // Props passed to your component renderer
}
```

## Submit Options

You can configure default submission behavior at the builder level using `.setSubmitOptions()`. These options control how validation interacts with form submission.

```tsx
import { rilay } from '@/lib/rilay';
import { required } from '@rilaykit/core';

const draftForm = rilay
  .form_OLD('draft-form')
  .add({ id: 'title', type: 'text', props: { label: 'Title' } })
  .add({
    id: 'content',
    type: 'textarea',
    props: { label: 'Content' },
    validation: { validate: required() },
  })
  .setSubmitOptions({ skipInvalid: true });
```

Two options are available:

| Option | Behavior |
|--------|----------|
| `force` | Bypass validation entirely and submit all current values as-is. Useful for "save draft" scenarios. |
| `skipInvalid` | Run validation (errors are still shown in the UI) but exclude invalid fields from the data passed to `onSubmit`. |

These defaults can be overridden at submit-time:

```tsx
const { submit } = useFormConfigContext();

await submit({ force: true });      // Bypass validation
await submit({ skipInvalid: true }); // Submit without invalid fields
```

<Callout>
When both `force` and `skipInvalid` are set, `force` takes priority (validation is skipped entirely).
</Callout>

---

## Complete Example: Login Form

Let's tie everything together. Here is how you would build a complete login form configuration, assuming you have a configured `rilay` instance. This definition can be passed directly to the `<Form>` component.

```tsx
import { rilay } from '@/lib/rilay';

export const loginForm = rilay
  .form_OLD('login-form')
  .add(
    {
      id: 'email',
      type: 'email',
      props: {
        label: 'Email Address',
        placeholder: 'Enter your email',
      },
    },
    {
      id: 'password',
      type: 'password',
      props: {
        label: 'Password',
        placeholder: 'Enter your password',
      },
    }
  );
```

This `loginForm` builder instance is now ready to be passed to your `<Form>` component. 