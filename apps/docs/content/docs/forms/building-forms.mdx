---
title: Building Forms
description: How to use the fluent API to build form configurations.
---
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';

Building a form configuration starts from your central `rilay` instance. By calling `rilay.createForm()`, you get a form builder that has access to all your pre-configured components and renderers.

<Callout>
Before proceeding, make sure you have created and configured a shared `rilay` instance as shown in the [Your First Form](/docs/getting-started/your-first-form) guide.
</Callout>

## The Form Building Process

<Steps>
<Step>
### 1. Start with `createForm()`

Call `.createForm()` on your `rilay` instance to begin a new form definition. You should provide a unique ID for your form.

```tsx
import { rilay } from '@/lib/rilay';

const loginForm = rilay.createForm('login');
```
</Step>
<Step>
### 2. Add Fields and Rows

The builder provides a fluent API to add fields and structure them in rows.

- **`.addField(fieldConfig)`**: Adds a single field that will be rendered in its own row.
- **`.addRowFields([fieldConfig, ...])`**: Adds a row containing one or more fields.

```tsx
const registrationForm = rilay
  .createForm('registration')
  .addRowFields([
    {
      id: 'firstName',
      type: 'text', // This type must exist in your component registry
      props: { label: 'First Name' },
    },
    {
      id: 'lastName',
      type: 'text',
      props: { label: 'Last Name' },
    },
  ])
  .addField({
    id: 'email',
    type: 'email', // Assumes an 'email' type is registered
    props: { label: 'Email Address' },
  });
```
</Step>

</Steps>

## When to use `.build()`

You may have noticed we don't always call `.build()` in our examples. This is because components like `<Form>` and workflow steps are smart enough to build the configuration for you.

However, you should call `.build()` manually when you need the final, serializable `FormConfiguration` object. For instance:

- To serialize the form and save it as JSON.
- To pass the configuration to a custom function or a third-party tool.
- For debugging purposes, to inspect the generated configuration.

```tsx
const formConfig = rilay
  .createForm('my-form')
  .addField({ id: 'field1', type: 'text' })
  .build(); // Manually build the config

console.log(formConfig.allFields);
```

## Field Configuration

The `fieldConfig` object you pass to `.addField()` or `.addRowFields()` has the following shape:

```ts
interface FieldConfig {
  id: string; // A unique identifier for the field within the form.
  type: string; // The component type to render from your registry.
  props?: Record<string, any>; // Props passed to your component renderer.
  validation?: ValidationConfig; // Validation rules for the field.
  conditional?: ConditionalConfig; // Logic to show/hide the field.
}
```
For more details on `validation`, see the [Validation](/core-concepts/validation) page. `conditional` logic is covered in the Advanced Forms guide.

---

## Complete Example: Login Form

Let's tie everything together. Here is how you would build a complete login form configuration, assuming you have a configured `rilay` instance. This definition can be passed directly to the `<Form>` component.

```tsx
import { rilay } from '@/lib/rilay';
import { z } from 'zod';

export const loginForm = rilay
  .createForm('login-form')
  .addFields([
    {
      id: 'email',
      type: 'email',
      props: {
        label: 'Email Address',
        placeholder: 'Enter your email',
      },
      validation: (v) =>
        v.string({ required_error: 'Email is required' })
         .email('Please enter a valid email address'),
    },
    {
      id: 'password',
      type: 'password',
      props: {
        label: 'Password',
        placeholder: 'Enter your password',
      },
      validation: (v) =>
        v.string().min(8, 'Password must be at least 8 characters long'),
    },
  ]);
```

This `loginForm` builder instance is now ready to be passed to your `<Form>` component. 