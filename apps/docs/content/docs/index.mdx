---
title: Introduction
description: A schema-first, type-safe React library for building forms and workflows with full UI flexibility.
---
import { Card, Cards } from 'fumadocs-ui/components/card';
import { FileCode, BotMessageSquare, Settings2, Sparkles } from 'lucide-react';
import { Callout } from 'fumadocs-ui/components/callout';

# RilayKit

**RilayKit** is a schema-first React library for building type-safe forms and workflows. Define your forms as data structures, register your components once, and let TypeScript propagate types through the entire chain — from component registry to rendered fields.

<Callout type="info">
RilayKit is fully **headless** — it manages state, validation, and logic. You bring the components, the markup, and the styling.
</Callout>

## What Makes RilayKit Different

Most form libraries are imperative: you write JSX, sprinkle in validation, and manually wire state. RilayKit inverts this — forms are **declarative configurations** that are serializable, composable, and fully type-safe.

Read the full story in [Why RilayKit](/why-rilaykit).

### Type Propagation

Register components with their prop types. TypeScript tracks everything — from the registry through form definitions to rendered fields. Invalid types and props are caught at compile time, not at runtime.

[Learn more about TypeScript support](/core-concepts/typescript-support)

### Universal Validation

Use any Standard Schema compatible library directly — Zod, Valibot, ArkType — or RilayKit's built-in validators. No adapters, no wrappers.

[Learn more about validation](/core-concepts/validation)

### Declarative Conditions

Control field visibility, disabled state, and requirements with a fluent condition API. No `useEffect`, no imperative state management.

[Learn more about conditions](/core-concepts/conditions)

### Workflow Engine

Build multi-step processes with step navigation, persistence, analytics, and a plugin system. Not a wizard with hidden divs — a real workflow engine.

[Learn more about workflows](/workflow/building-workflows)

## Quick Example

```tsx
import { ril, required, email, minLength } from '@rilaykit/core';
import { Form, FormField } from '@rilaykit/forms';

// 1. Register your components once
const rilay = ril.create()
  .addComponent('input', { renderer: YourInputComponent });

// 2. Define forms as data
const loginForm = rilay
  .form('login')
  .add({ id: 'email', type: 'input', props: { label: 'Email' }, validation: { validate: [required(), email()] } })
  .add({ id: 'password', type: 'input', props: { label: 'Password' }, validation: { validate: [required(), minLength(8)] } });

// 3. Render with full type safety
<Form formConfig={loginForm} onSubmit={handleLogin}>
  <FormField fieldId="email" />
  <FormField fieldId="password" />
</Form>
```

## Packages

RilayKit is modular. Install only what you need.

<Cards>
  <Card
    icon={<Settings2/>}
    title="@rilaykit/core"
    description="Type system, component registry, validation engine, and conditional logic. Required as the foundation for all RilayKit usage."
  />
  <Card
    icon={<FileCode/>}
    title="@rilaykit/forms"
    description="Form builder with React hooks and components. Build single-page forms with fluent API and full type safety."
  />
  <Card
    icon={<BotMessageSquare/>}
    title="@rilaykit/workflow"
    description="Multi-step workflows with navigation, persistence, analytics, and plugin system. For onboarding flows and complex processes."
  />
  <Card
    icon={<Sparkles/>}
    title="Standard Schema Support"
    description="Native support for Standard Schema — use Zod, Yup, Valibot, ArkType and other validation libraries directly without adapters."
  />
</Cards>

## Design Principles

### Bring Your Own Components
RilayKit generates no HTML and no CSS. It connects to your existing components through a renderer system, giving you complete control over markup, styling, and accessibility.

### Extensible by Design
Every layer is customizable — validators, conditions, renderers, workflow plugins. Build exactly the form system your product needs.

### Type Safety First
Built from the ground up with TypeScript. The type accumulation pattern ensures autocompletion, compile-time validation, and zero runtime type errors across your entire form system.

## Getting Started

Start with the [installation guide](/getting-started/installation) or jump straight into [building your first form](/getting-started/your-first-form).

For a faster introduction, try the [Quick Start](/quickstart) guide.
