---
title: Advanced Workflows
description: Learn about advanced workflow features including dynamic steps, hooks, and analytics
---
import { Callout } from 'fumadocs-ui/components/callout';

The `flow` builder, like the `formBuilder`, is more than a simple configuration tool. It offers advanced features for creating highly dynamic and powerful user flows.

## Dynamic Step Management

You can modify a workflow's steps after the builder has been initialized.

- **`.updateStep(stepId, updates)`**: Modifies an existing step's configuration.
- **`.removeStep(stepId)`**: Removes a step from the workflow.
- **`.getStep(stepId)`**: Retrieves the configuration for a specific step.
- **`.getSteps()`**: Returns an array of all step configurations.
- **`.clearSteps()`**: Removes all steps.

```tsx
import { rilay } from '@/lib/rilay';

const myFlow = rilay.flow('my-flow', 'My Dynamic Flow')
  .addStep({ id: 'step1', ... });

// Later, based on some condition...
if (user.isAdmin) {
  myFlow.addStep({ id: 'admin-step', ... });
}

// Or update a step
myFlow.updateStep('step1', {
  title: 'Step 1 (Updated)'
});

const workflowConfig = myFlow.build();
```

## Cloning

The `.clone(newWorkflowId?, newWorkflowName?)` method creates a deep copy of the builder instance, allowing you to create variations of a workflow.

```tsx
const baseFlow = rilay.flow('base', 'Base Flow').addStep({ id: 'a', ... });
const variantFlow = baseFlow.clone('variant', 'Variant Flow').addStep({ id: 'b', ... });
```

## Serialization (JSON Import/Export)

Workflow configurations can be serialized to and from JSON. This is useful for storing flow definitions in a database or building visual workflow editors.

- **`.toJSON()`**: Exports the current workflow structure as a JSON-serializable object.
- **`.fromJSON(json)`**: Populates a builder instance from a JSON object.

```tsx
// 1. Define and serialize
const originalFlow = rilay.flow('flow1', 'Flow 1').addStep(...);
const jsonDefinition = originalFlow.toJSON();

// 2. Later, rehydrate from the definition
const newFlow = rilay.flow('flow2', 'Flow 2').fromJSON(jsonDefinition);
const workflowConfig = newFlow.build();
```

## Plugins

Rilaykit's workflow builder supports a plugin architecture to extend its functionality. A plugin is an object with a name, version, and an `install` method that gets called with the builder instance.

This is an advanced feature for creating reusable pieces of workflow logic.

```tsx
// Example of a simple logging plugin
const loggingPlugin = {
  name: 'simple-logger',
  version: '1.0.0',
  install(builder) {
    const existingAnalytics = builder.build().analytics || {};
    builder.setAnalytics({
      ...existingAnalytics,
      onStepStart: (stepId) => {
        console.log(`PLUGIN: Step started: ${stepId}`);
        existingAnalytics.onStepStart?.(stepId);
      }
    });
  }
};

// Use it
const myFlow = rilay.flow('my-flow', 'My Flow')
  .use(loggingPlugin)
  .addStep(...)
  .build();
```
The builder also supports `.removePlugin(pluginName)` and validates plugin dependencies.

## Introspection

The `.getStats()` method provides a quick overview of the workflow's structure.

```ts
const stats = myFlowBuilder.getStats();
console.log(stats);
/*
{
  totalSteps: 3,
  dynamicSteps: 0,
  pluginsInstalled: 1,
  estimatedFields: 10,
  hasPersistence: false,
  hasAnalytics: true,
  allowBackNavigation: true
}
*/
```
This is useful for debugging or analyzing the complexity of your workflows. 

# Advanced Workflows

This guide covers advanced workflow features that help you build complex, dynamic workflows with sophisticated validation and data management.

### Best Practices



// Step 1: Business Registration Form
const businessRegistrationForm = form.create(config, 'business-registration')
  .add({
    type: 'select',
    props: {
      label: 'Country',
      placeholder: 'Select your country',
      options: [
        { value: 'US', label: 'United States' },
        { value: 'FR', label: 'France' },
        { value: 'DE', label: 'Germany' },
        { value: 'UK', label: 'United Kingdom' },
        { value: 'CA', label: 'Canada' },
      ],
    },
  })
  .add({
    type: 'text',
    props: {
      label: 'Business Registration Number',
      placeholder: 'Enter your business registration number',
      helperText: 'EIN (US), SIREN (FR), HRB (DE), Companies House (UK), etc.',
    },
  })
  .build();

// Step 2: Company Details Form (will be pre-filled)
const companyDetailsForm = form.create(config, 'company-details')
  .add({
    type: 'text',
    props: {
      label: 'Company Name',
      disabled: true, // Will be filled from API
    },
  })
  .add({
    type: 'text',
    props: {
      label: 'Legal Form',
      disabled: true,
    },
  })
  .add({
    type: 'textarea',
    props: {
      label: 'Registered Address',
      disabled: true,
    },
  })
  .add({
    type: 'text',
    props: {
      label: 'Contact Email',
      placeholder: 'contact@company.com',
    },
  })
  .build();

// Create workflow with step transition validation
const businessOnboardingWorkflow = flow.create(
  config,
  'business-onboarding',
  'Business Onboarding'
)
  .addStep({
    id: 'registration',
    title: 'Business Registration',
    formConfig: businessRegistrationForm,
    hooks: {
      onStepTransition: async (stepData, allData, context) => {
        const { country, registrationNumber } = stepData;
        
        // Validate required fields
        if (!country || !registrationNumber) {
          return {
            isValid: false,
            errors: [
              {
                code: 'required_fields',
                message: 'Country and registration number are required',
              },
            ],
          };
        }

        try {
          // Call API to validate and fetch business data
          const businessData = await validateBusinessRegistration(
            registrationNumber,
            country
          );

          // Return success with pre-filled data for next step
          return {
            isValid: true,
            errors: [],
            modifiedData: {
              // Store the full business data
              businessInfo: businessData,
              validatedAt: new Date().toISOString(),
            },
            nextStepData: {
              // Pre-fill the next step form
              companyName: businessData.name,
              legalForm: businessData.legalForm,
              registeredAddress: businessData.address,
            },
          };
        } catch (error) {
          // Handle validation errors
          if (error.status === 404) {
            return {
              isValid: false,
              errors: [
                {
                  code: 'invalid_registration',
                  message: 'Business registration number not found',
                },
              ],
            };
          }

          return {
            isValid: false,
            errors: [
              {
                code: 'validation_error',
                message: 'Unable to validate registration number. Please try again.',
              },
            ],
          };
        }
      },
    },
  })
  .addStep({
    id: 'company-details',
    title: 'Company Details',
    formConfig: companyDetailsForm,
  })
  .addStep({
    id: 'verification',
    title: 'Verification',
    formConfig: verificationForm,
  })
  .build();
```

### Using the Step Error Management Functions

The workflow context provides functions to manage step-level errors:

```typescript
import { useWorkflowContext } from '@rilaykit/workflow';

function BusinessRegistrationStep() {
  const {
    getCurrentStepErrors,
    isCurrentStepValidating,
    goNext,
  } = useWorkflowContext();

  const stepErrors = getCurrentStepErrors();
  const isValidating = isCurrentStepValidating();

  return (
    <div>
      <WorkflowBody />
      
      {/* Display step-level errors */}
      {stepErrors.length > 0 && (
        <div className="error-panel">
          <h4>Validation Errors:</h4>
          <ul>
            {stepErrors.map((error, index) => (
              <li key={index} className="error-message">
                {error.message}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Navigation buttons */}
      <div className="navigation">
        <WorkflowPreviousButton />
        <WorkflowNextButton disabled={isValidating}>
          {isValidating ? 'Validating...' : 'Continue'}
        </WorkflowNextButton>
      </div>
    </div>
  );
}
```

### Tax ID Validation Example

Here's another example for tax ID validation that works across multiple countries:

```typescript
const taxIdValidationStep = {
  id: 'tax-validation',
  title: 'Tax Information',
  formConfig: taxIdForm,
  hooks: {
    onStepTransition: async (stepData, allData, context) => {
      const { country, taxId } = stepData;
      
      try {
        // Different validation patterns by country
        const validationRules = {
          US: /^\d{2}-\d{7}$/, // EIN format
          FR: /^\d{11}$/, // SIRET format
          DE: /^\d{11}$/, // Steuernummer format
          UK: /^\d{10}$/, // UTR format
          CA: /^\d{9}$/, // BN format
        };

        const pattern = validationRules[country];
        if (!pattern || !pattern.test(taxId)) {
          return {
            isValid: false,
            errors: [
              {
                code: 'invalid_format',
                message: `Invalid tax ID format for ${country}`,
              },
            ],
          };
        }

        // Validate with tax authority API
        const response = await fetch(`/api/tax/validate/${country}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ taxId }),
        });

        if (!response.ok) {
          return {
            isValid: false,
            errors: [
              {
                code: 'tax_validation_failed',
                message: 'Tax ID could not be verified with authorities',
              },
            ],
          };
        }

        const taxData = await response.json();

        return {
          isValid: true,
          errors: [],
          modifiedData: {
            taxInfo: taxData,
            taxValidatedAt: new Date().toISOString(),
          },
          nextStepData: {
            taxStatus: taxData.status,
            registeredName: taxData.registeredName,
          },
        };
      } catch (error) {
        return {
          isValid: false,
          errors: [
            {
              code: 'api_error',
              message: 'Unable to validate tax ID. Please try again later.',
            },
          ],
        };
      }
    },
  },
};
```

### Best Practices

1. **Error Handling**: Always provide meaningful error messages in the user's language
2. **Loading States**: Use `isCurrentStepValidating()` to show loading indicators
3. **Fallback Validation**: Have client-side validation as a fallback
4. **API Timeouts**: Implement proper timeout handling for API calls
5. **Retry Logic**: Consider implementing retry mechanisms for transient failures

```typescript
// Example with retry logic
const retryApiCall = async (fn: () => Promise<any>, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
};

// Usage in onStepTransition
onStepTransition: async (stepData, allData, context) => {
  try {
    const result = await retryApiCall(() => 
      validateBusinessRegistration(stepData.registrationNumber, stepData.country)
    );
    
    return {
      isValid: true,
      errors: [],
      modifiedData: { businessInfo: result },
    };
  } catch (error) {
    return {
      isValid: false,
      errors: [{ code: 'api_error', message: 'Validation failed after retries' }],
    };
  }
},
```

This approach provides a robust, international-friendly way to handle step transitions with API validation that can adapt to different countries and regulatory requirements. 