import type {
  ExportFormat,
  ExportOptions,
  SerializedBuilder,
  SerializedFormBuilder,
  SerializedWorkflowBuilder,
} from '../types';
import { toJSONString } from './serialization';

/**
 * Default export options
 */
const DEFAULT_EXPORT_OPTIONS: ExportOptions = {
  format: 'json',
  pretty: true,
  includeMetadata: true,
  includeComments: false,
};

/**
 * Exports serialized builder data to specified format
 *
 * @param data - Serialized builder data
 * @param options - Export options
 * @returns Formatted export string
 *
 * @example
 * ```typescript
 * const exported = exportBuilder(serializedData, {
 *   format: 'typescript',
 *   pretty: true,
 *   includeComments: true
 * });
 * ```
 */
export const exportBuilder = (
  data: SerializedBuilder,
  options: Partial<ExportOptions> = {}
): string => {
  const opts = { ...DEFAULT_EXPORT_OPTIONS, ...options };

  switch (opts.format) {
    case 'json':
      return exportToJSON(data, opts);
    case 'typescript':
      return exportToTypeScript(data, opts);
    case 'javascript':
      return exportToJavaScript(data, opts);
    default:
      throw new Error(`Unsupported export format: ${opts.format}`);
  }
};

/**
 * Exports to JSON format
 */
const exportToJSON = (data: SerializedBuilder, options: ExportOptions): string => {
  if (!options.includeMetadata) {
    // Remove metadata from export
    const { metadata, ...dataWithoutMetadata } = data;
    return options.pretty
      ? JSON.stringify(dataWithoutMetadata, null, 2)
      : JSON.stringify(dataWithoutMetadata);
  }

  return options.pretty ? toJSONString(data, 2) : JSON.stringify(data);
};

/**
 * Exports to TypeScript code format
 */
const exportToTypeScript = (data: SerializedBuilder, options: ExportOptions): string => {
  const lines: string[] = [];
  const indent = options.pretty ? '  ' : '';
  const nl = options.pretty ? '\n' : '';

  // Add file header comment
  if (options.includeComments) {
    lines.push('/**');
    lines.push(` * ${data.name}`);
    if (data.metadata.description) {
      lines.push(` * ${data.metadata.description}`);
    }
    lines.push(` * Generated by RilayKit Builder on ${new Date().toISOString()}`);
    lines.push(' */');
    lines.push('');
  }

  // Add imports
  if (data.type === 'form') {
    lines.push("import { form } from '@rilaykit/forms';");
    lines.push("import { ril } from '@rilaykit/core';");
  } else {
    lines.push("import { flow } from '@rilaykit/workflow';");
    lines.push("import { ril } from '@rilaykit/core';");
  }
  lines.push('');

  // Add builder code
  if (data.type === 'form') {
    lines.push(...generateFormBuilderCode(data, indent, nl, options));
  } else {
    lines.push(...generateWorkflowBuilderCode(data, indent, nl, options));
  }

  return lines.join(nl);
};

/**
 * Exports to JavaScript code format
 */
const exportToJavaScript = (data: SerializedBuilder, options: ExportOptions): string => {
  const lines: string[] = [];
  const indent = options.pretty ? '  ' : '';
  const nl = options.pretty ? '\n' : '';

  // Add file header comment
  if (options.includeComments) {
    lines.push('/**');
    lines.push(` * ${data.name}`);
    if (data.metadata.description) {
      lines.push(` * ${data.metadata.description}`);
    }
    lines.push(` * Generated by RilayKit Builder on ${new Date().toISOString()}`);
    lines.push(' */');
    lines.push('');
  }

  // Add imports (CommonJS or ESM based on pretty flag)
  if (data.type === 'form') {
    lines.push("const { form } = require('@rilaykit/forms');");
    lines.push("const { ril } = require('@rilaykit/core');");
  } else {
    lines.push("const { flow } = require('@rilaykit/workflow');");
    lines.push("const { ril } = require('@rilaykit/core');");
  }
  lines.push('');

  // Add builder code
  if (data.type === 'form') {
    lines.push(...generateFormBuilderCode(data, indent, nl, options, false));
  } else {
    lines.push(...generateWorkflowBuilderCode(data, indent, nl, options, false));
  }

  return lines.join(nl);
};

/**
 * Generates TypeScript/JavaScript code for form builder
 */
const generateFormBuilderCode = (
  data: SerializedFormBuilder,
  indent: string,
  _nl: string,
  options: ExportOptions,
  useTypeScript = true
): string[] => {
  const lines: string[] = [];
  const typeAnnotation = useTypeScript ? ': form<any>' : '';

  if (options.includeComments) {
    lines.push('// Create your RilayKit configuration');
    lines.push('// Add your components here');
  }

  lines.push(`const rilConfig${useTypeScript ? ': ril<any>' : ''} = ril.create();`);
  lines.push('');

  if (options.includeComments) {
    lines.push(`// Create form builder: ${data.name}`);
  }

  lines.push(
    `const formBuilder${typeAnnotation} = form.create(rilConfig, '${data.config.formId}');`
  );
  lines.push('');

  // Load configuration from JSON
  lines.push('formBuilder.fromJSON({');
  lines.push(`${indent}id: '${data.config.formId}',`);
  lines.push(`${indent}rows: ${JSON.stringify(data.config.rows, null, options.pretty ? 2 : 0)},`);
  if (data.config.validation) {
    lines.push(
      `${indent}validation: ${JSON.stringify(data.config.validation, null, options.pretty ? 2 : 0)},`
    );
  }
  lines.push('});');
  lines.push('');

  if (options.includeComments) {
    lines.push('// Build the final configuration');
  }

  lines.push(
    `const formConfig${useTypeScript ? ': FormConfiguration' : ''} = formBuilder.build();`
  );
  lines.push('');

  if (options.includeComments) {
    lines.push('// Export for use in your application');
  }

  lines.push('export default formConfig;');

  return lines;
};

/**
 * Generates TypeScript/JavaScript code for workflow builder
 */
const generateWorkflowBuilderCode = (
  data: SerializedWorkflowBuilder,
  indent: string,
  _nl: string,
  options: ExportOptions,
  useTypeScript = true
): string[] => {
  const lines: string[] = [];
  const typeAnnotation = useTypeScript ? ': flow' : '';

  if (options.includeComments) {
    lines.push('// Create your RilayKit configuration');
    lines.push('// Add your components here');
  }

  lines.push(`const rilConfig${useTypeScript ? ': ril<any>' : ''} = ril.create();`);
  lines.push('');

  if (options.includeComments) {
    lines.push(`// Create workflow builder: ${data.name}`);
  }

  lines.push(
    `const flowBuilder${typeAnnotation} = flow.create(rilConfig, '${data.config.id}', '${data.config.name}');`
  );
  lines.push('');

  // Load configuration from JSON
  lines.push('flowBuilder.fromJSON({');
  lines.push(`${indent}id: '${data.config.id}',`);
  lines.push(`${indent}name: '${data.config.name}',`);
  if (data.config.description) {
    lines.push(`${indent}description: '${data.config.description}',`);
  }
  lines.push(`${indent}steps: ${JSON.stringify(data.config.steps, null, options.pretty ? 2 : 0)},`);
  lines.push('});');
  lines.push('');

  if (options.includeComments) {
    lines.push('// Build the final configuration');
  }

  lines.push(
    `const workflowConfig${useTypeScript ? ': WorkflowConfig' : ''} = flowBuilder.build();`
  );
  lines.push('');

  if (options.includeComments) {
    lines.push('// Export for use in your application');
  }

  lines.push('export default workflowConfig;');

  return lines;
};

/**
 * Creates a downloadable file from export content
 *
 * @param content - Export content
 * @param filename - Name for the downloaded file
 * @param format - Export format (used to determine file extension)
 *
 * @example
 * ```typescript
 * const exported = exportBuilder(data, { format: 'typescript' });
 * downloadExport(exported, 'my-form', 'typescript');
 * ```
 */
export const downloadExport = (content: string, filename: string, format: ExportFormat): void => {
  const extension = getFileExtension(format);
  const fullFilename = `${filename}.${extension}`;
  const blob = new Blob([content], { type: getMimeType(format) });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  link.download = fullFilename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

/**
 * Gets file extension for export format
 */
const getFileExtension = (format: ExportFormat): string => {
  switch (format) {
    case 'json':
      return 'json';
    case 'typescript':
      return 'ts';
    case 'javascript':
      return 'js';
    default:
      return 'txt';
  }
};

/**
 * Gets MIME type for export format
 */
const getMimeType = (format: ExportFormat): string => {
  switch (format) {
    case 'json':
      return 'application/json';
    case 'typescript':
    case 'javascript':
      return 'text/plain';
    default:
      return 'text/plain';
  }
};

/**
 * Copies export content to clipboard
 *
 * @param content - Content to copy
 * @returns Promise that resolves when copy is complete
 *
 * @example
 * ```typescript
 * const exported = exportBuilder(data);
 * await copyToClipboard(exported);
 * ```
 */
export const copyToClipboard = async (content: string): Promise<void> => {
  if (navigator.clipboard && window.isSecureContext) {
    await navigator.clipboard.writeText(content);
  } else {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = content;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    document.execCommand('copy');
    textArea.remove();
  }
};
